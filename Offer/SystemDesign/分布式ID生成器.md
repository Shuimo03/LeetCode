### 应用场景(Scenario)

现实中很多业务都有生成唯一ID的需求，如下所示：

+ 用户id
+ 微博id
+ 聊天信息id
+ 帖子id
+ 订单id

### 需求(Needs)

大部分ID都会做成数据库的主键，所以为了保证全局唯一性，数据库需要在这个字段上建立聚集索引，即该字段会影响到各条数据在物理存储上的顺序，同时ID还要尽可能的短，节省内存，让数据库索引效率更高。

需要根据具体业务进行分析，预估出ID的最大值，这个最大值通常比64位整数的上限小很多，于是我们可以用更少的bit表示这个ID。

查询的时候，往往有分页或者排序的需求，所以需要给每条数据添加一个时间字段，并在其上建立普通索引(Secondary Index)。但是普通索引的访问效率比聚集索引慢，如果能够让ID按照时间粗略有序，则可以省去这个时间字段。为什么不是按照时间精确有序呢？因为按照时间精确有序是做不到的，除非用一个单机算法，在分布式场景下做到精确有序性能一般很差。

这就引出了ID生成的三大核心需求:

+ 全局唯一
+ 按照时间粗略有序
+ 尽可能的短

### 常用生成ID的方法

+ UUID
+ 多台MySQL服务器
+ Twitter Snowflake

### UUID

### 