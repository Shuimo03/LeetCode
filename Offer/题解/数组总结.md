## 数组常见的解法

+ 二分查找
+ 排序
+ 双指针
+ DFS
+ 滑动窗口
+ 前缀和
+ 哈希表

已经把剑指offer上关于数组的简单题过了一遍，其中最常用的还是双指针和二分查找，这里选几题来做下代表。

## 双指针例题

### 剑指Offer 03:数组中重复的数字

首先来看剑指offer的第三题**数组中重复的数字**，题目的意思很简单，只要找出数组中重复的数字就可以了，一开始可以直接暴力方法来写：

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        sort(nums.begin(),nums.end());
       int cnt = 0;
       for(int i = 0; i < nums.size(); i++){
           for(int j = i+1; j < nums.size(); j++){
               if(nums[i] == nums[j]){
                  return nums[i];
               }
           }
       }
       return 0;
    }
};
```

显然易见，这个解法的时间复杂度是O(N^2)，而且还超出了时间限制，我们使用排序+快慢指针来优化一下，时间复杂度是O(nlogn)。

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        if(nums.size() == 0){
            return 0;
        }
        sort(nums.begin(),nums.end());

        int l = 0;
        int r = 1;
        
        for(int i = 0; i < nums.size(); i++){
            if(nums[l] == nums[r]){
                return nums[i];
            }
            l++;
            r++;
        }
        return 0;
    }
};
```

首先将数组排序，随后设置两个指针l和r，当两个指针相等的时候，说明找到了重复的值，直接返回nums[l]就可以了。下面是省了一个变量的做法，要比上面的更快一点。

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        for(int i = 0; i < nums.size();i++){
            if(nums[i] == nums[i+1]){
                return nums[i];
            }
        }
        return 0;
    }
};
```

最后一种，也就是空间换时间，将时间复杂度降到O(n),但是空间复杂度是O(n)，使用哈希表

## 二分查找

### 剑指Offer 53 - I:在排序数组中查找数字 I