## 数组常见的解法

+ 二分查找
+ 排序
+ 双指针
+ DFS
+ 滑动窗口
+ 前缀和
+ 摩尔投票
+ 哈希表

## 例题讲解

#### [剑指 Offer 03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例 1：

输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 


限制：

2 <= n <= 100000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 解题思路

排序+双指针(时间复杂度 O(nlogn))

因为数组不是排序好的，所以一开始双指针不能使用，我们可以进行排序，然后设置两个快慢指针进行对比，如果不相等的话两个指针就会一起移动。

```
[2,3,1,0,2,5,3] //排序前
[0,1,2,2,3,3,5] //排序后,l指向0，r指向1，不相等两个指针向后移动
[0,1|,2,2,3,3,5] // l指向2,r指向2,两个相等返回结果，|表示分界线
```

具体的时间复杂度看排序的算法，这种思路比较简单，但是复杂度比较高。

```C++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int l  = 0; 
        int r = 1;
        for(int i = 0; i < nums.size(); i++){
            if(nums[l] == nums[r]){
                return nums[i];
            }
            l++;
            r++;
        }
        return 0;
    }
};
```

#### [剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

示例 1：

输入：[3,4,5,1,2]
输出：1
示例 2：

输入：[2,2,2,0,1]
输出：0
注意：本题与主站 154 题相同：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 解题思路

最简单粗暴的方法，直接将数组排序，然后返回数组的第一个元素就可以了。

```java
class Solution {
public:
    int minArray(vector<int>& numbers) {
        if(numbers.size() == 0){
            return 0;
        }
        sort(numbers.begin(),numbers.end());
        return numbers[0];
    }
};
```

不过这种方式，面试官肯定是不会喜欢的，所以要换个思路，可以使用二分查找法来实现：

**todo**

#### [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

示例：

输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。


提示：

1. 0 <= nums.length <= 50000
2. 0 <= nums[i] <= 10000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 解题思路

根据题目给出的输入数组看得出来是一个有序数组，所以可以使用双指针的方法，设两个指针l和r，分别指向数组第一个元素和最后一个元素。

nums[l]如果遇到的是奇数，那它就会自增，找到下一个偶数，nums[r]也是一个道理，如果是偶数就会自增，然后找到下一个奇数，在交换两个数字，最后返回nums就行。

```
[1,2,3,4] // 初始状态
[l,2,3,r] // 此刻l指向数组第一个元素，r指向最后一个元素，因为l指向的是1，r指向的是4，满足之前说的，所以自增。
[1,l,r,4] //交换位置
[1,3,2,4] // 返回结果
```



```c++
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        int l = 0;
        int r = nums.size()-1;
        while(l < r){
            if(l < r && (nums[l]&1) == 1) l++;
            if(l < r && (nums[r]&1) == 0) r--;
            swap(nums[l],nums[r]);
        }
        return nums;
    }
};
```

#### [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

难度简单212

统计一个数字在排序数组中出现的次数。

**示例 1:**

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
```

**示例 2:**

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
```

**提示：**

- `0 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`
- `nums` 是一个非递减数组
- `-109 <= target <= 109`

 

**注意：**本题与主站 34 题相同（仅返回值不同）：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/

#### 解题思路

这题解法比较多:

+ 使用map统计出现次数。
+ 使用二分搜索
+ 最无脑的直接遍历一遍

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        unordered_map<int,int> cntMap;
        for(auto n:nums){
            cntMap[n]++;
        }
        
        if(cntMap.find(target) != cntMap.end()){
            return cntMap[target];
        }
        return 0;
    }
};
```

最无脑的方法，直接遍历，设置一个变量，遇到target的就加一。

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int cnt = 0;
        for(int i = 0; i < nums.size(); i++){
            if(nums[i] == target){
                cnt++;
            }
        }
        return cnt;
    }
};
```

二分搜索

