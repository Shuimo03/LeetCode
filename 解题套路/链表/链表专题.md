### 链表介绍

链表的顺序是每个对象里面的指针决定的，双向链表的每个元素都是一个对象，每个对象都有一个关键字和两个指针。

链表可以方便的删除、插入数据，操作的时间复杂度是O(1)，但是查找效率不高，时间复杂度是O(n)。

数组因为是连续内存地址，所有它在随机访问的时间复杂度是O(1)，但是删除和插入是O(n)。

### 链表种类

+ 单链表
+ 双链表
+ 循环链表
  + 单向循环列表
  + 双向循环链表

单链表和双链表的共同点是：

+ 它们都没办法在常量时间内随机访问数据。
+ 它们都能够在O(1)时间内给定节点之后或者列表开头添加一个新结点。
+ 它们都能够在O(1)时间内删除第一个结点。

但是删除给定结点(包括最后一个结点)的时候有所不同：

+ 单链表无法在O(1)时间内删除给定节点的前一个节点，所以就需要O(N)时间找出前一个结点。
+ 双链表可以在O(1)时间内删除前一个结点，因为可以使用prev引用字段获取前一个结点。

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/04/29/screen-shot-2018-04-28-at-174531.png)

### 解题模板

+ 递归
+ 迭代
+ 双指针
  + 快慢指针
  + 先后指针

### 推荐题号

+ 剑指pffer25  合并两个排序的链表
+ 剑指offer06 从尾到头打印链表
+ 剑指offer22  链表中倒数第k个节点
+ 剑指offer24 反转链表
+ 剑指 Offer18 删除链表的节点
+ 剑指 Offer52 两个链表的第一个公共节点

### 题解

####  合并两个排序的链表

根据题意，晓得l1和l2都是递增排序的，所以可以考虑双指针遍历两个链表，同时比较两个链表的值。

因为初始状态合并链表中没有节点，所以需要初始化一个辅助结点dum作为合并链表的伪头节点，将每个结点添加到dum之后。

[面试题25. 合并两个排序的链表（伪头节点，清晰图解） - 合并两个排序的链表 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/solution/mian-shi-ti-25-he-bing-liang-ge-pai-xu-de-lian-b-2/)

#### 从尾到头打印链表

[剑指 Offer 06. 从尾到头打印链表 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

通过输入输出样例，可以发现这是一个先进后出的规律，所以就就符合了栈的要求，我们只需要去模拟栈的操作就可以了。

```Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int[] reversePrint(ListNode head) {

        Stack<ListNode> stack = new Stack<>();
        ListNode L1 = head;
        while(L1 != null){
            stack.push(L1);
            L1 = L1.next;
        }

        int length = stack.size();
        int arr[] = new int[length];
        for(int i = 0; i < length; i++){
            arr[i] = stack.pop().val;
        }
        return arr;
    }
}
```

#### 剑指offer22  链表中倒数第k个节点

[剑指 Offer 22. 链表中倒数第k个节点 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

这道题有两种做法，第一种比较简单也容易想到，我们可以用链表长度减去K，这样就获取到倒数第K个结点，首先是我们需要遍历链表来获取它的长度。

```java
int listLength = 0;
while (head != null){
            head = head.next;
            listLength++;
        }
```

接着我们还要遍历一次，来到K结点。

```java
        for (int i = 0; i < listLength-k; i++){
            dum = dum.next;
        }
```

```java
public ListNode getKthFromEnd(ListNode head, int k) {
    ListNode dum = head,cur = head;
    int listLength = 0;
    while (head != null){
        head = head.next;
        listLength++;
    }

    for (int i = 0; i < listLength-k; i++){
        dum = dum.next;
    }
    return dum;
}
```

做法二：使用双指针，使用双指针的好处在于可以不用遍历两次，省去了计算链表长度，

